
// Copyright (c) 2010-2014 niXman (i dot nixman dog gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _yas__detail__io__convertors_hpp
#define _yas__detail__io__convertors_hpp

#include <yas/detail/config/config.hpp>

#include <yas/detail/type_traits/type_traits.hpp>

#include <cstring>
#include <cmath>

namespace yas {
namespace detail {

/***************************************************************************/

#if YAS_LITTLE_ENDIAN()

template<typename T>
struct storage_type {
	enum {
		 is_float  = std::is_same<T, float>::value
		,is_double = std::is_same<T, double>::value
	};
	static_assert(is_float||is_double,"only double or float types allowed");

	using type = typename std::conditional<
		 is_float
		,std::uint32_t
		,std::uint64_t
	>::type;

	template<typename U>
	static void bswab(U &u, typename std::enable_if<std::is_same<U, std::uint32_t>::value>::type* = 0) {
		YAS_NETWORK_TO_LOCAL32(u, u);
	}
	template<typename U>
	static void bswab(U &u, typename std::enable_if<std::is_same<U, std::uint64_t>::value>::type* = 0) {
		YAS_NETWORK_TO_LOCAL64(u, u);
	}
};

template<typename T>
void to_network(std::uint8_t *dst, const T &v) {
	union {
		typename storage_type<T>::type u;
		T v;
	} u;
	u.v = v;

	storage_type<T>::bswab(u.u);
	std::memcpy(dst, &u.u, sizeof(T));
}

template<typename T>
void from_network(T &v, const std::uint8_t *src) {
	union {
		typename storage_type<T>::type u;
		T v;
	} u;

	std::memcpy(&u.u, src, sizeof(v));
	storage_type<T>::bswab(u.u);
	v = u.v;
}

#else

template<typename T>
void to_network(std::uint8_t *dst, const T &v) {
	*((T*)dst) = v;
}

template<typename T>
void from_network(T &v, const std::uint8_t *src) {
	v = ((T*)src);
}

#endif

/***************************************************************************/

template<typename T>
T atou(const char *str, std::size_t len) {
	T val = 0;

	switch ( len ) {
		case 20:	val += (str[len-20] - '0') * 10000000000000000000ull;
		case 19:	val += (str[len-19] - '0') * 1000000000000000000ull;
		case 18:	val += (str[len-18] - '0') * 100000000000000000ull;
		case 17:	val += (str[len-17] - '0') * 10000000000000000ull;
		case 16:	val += (str[len-16] - '0') * 1000000000000000ull;
		case 15:	val += (str[len-15] - '0') * 100000000000000ull;
		case 14:	val += (str[len-14] - '0') * 10000000000000ull;
		case 13:	val += (str[len-13] - '0') * 1000000000000ull;
		case 12:	val += (str[len-12] - '0') * 100000000000ull;
		case 11:	val += (str[len-11] - '0') * 10000000000ull;
		case 10:	val += (str[len-10] - '0') * 1000000000ull;
		case  9:	val += (str[len- 9] - '0') * 100000000ull;
		case  8:	val += (str[len- 8] - '0') * 10000000ull;
		case  7:	val += (str[len- 7] - '0') * 1000000ull;
		case  6:	val += (str[len- 6] - '0') * 100000ull;
		case  5:	val += (str[len- 5] - '0') * 10000ull;
		case  4:	val += (str[len- 4] - '0') * 1000ull;
		case  3:	val += (str[len- 3] - '0') * 100ull;
		case  2:	val += (str[len- 2] - '0') * 10ull;
		case  1:	val += (str[len- 1] - '0') * 1ull;
			return val;
		default:
			return 0;
	}
}

template<typename T>
T atoi(const char *str, std::size_t len) {
	T val = 0;
	int sign = 1;
	if ( *str == '-' ) {
		sign = -1;
		++str;
		--len;
	}

	switch ( len ) {
		case 19: val += (str[len-19] - '0') * 1000000000000000000ll;
		case 18:	val += (str[len-18] - '0') * 100000000000000000ll;
		case 17:	val += (str[len-17] - '0') * 10000000000000000ll;
		case 16:	val += (str[len-16] - '0') * 1000000000000000ll;
		case 15:	val += (str[len-15] - '0') * 100000000000000ll;
		case 14:	val += (str[len-14] - '0') * 10000000000000ll;
		case 13:	val += (str[len-13] - '0') * 1000000000000ll;
		case 12:	val += (str[len-12] - '0') * 100000000000ll;
		case 11:	val += (str[len-11] - '0') * 10000000000ll;
		case 10:	val += (str[len-10] - '0') * 1000000000ll;
		case  9:	val += (str[len- 9] - '0') * 100000000ll;
		case  8:	val += (str[len- 8] - '0') * 10000000ll;
		case  7:	val += (str[len- 7] - '0') * 1000000ll;
		case  6:	val += (str[len- 6] - '0') * 100000ll;
		case  5:	val += (str[len- 5] - '0') * 10000ll;
		case  4:	val += (str[len- 4] - '0') * 1000ll;
		case  3:	val += (str[len- 3] - '0') * 100ll;
		case  2:	val += (str[len- 2] - '0') * 10ll;
		case  1:	val += (str[len- 1] - '0') * 1ll;
			val *= sign;
			return val;
		default:
			return 0;
	}
}

/***************************************************************************/

template<typename T>
std::uint32_t utoa(T v, char *buf) {
	std::size_t digits = 0;
	if ( v < 10ull ) digits = 1;
	else if ( v < 100ull ) digits = 2;
	else if ( v < 1000ull ) digits = 3;
	else if ( v < 10000ull ) digits = 4;
	else if ( v < 100000ull ) digits = 5;
	else if ( v < 1000000ull ) digits = 6;
	else if ( v < 10000000ull ) digits = 7;
	else if ( v < 100000000ull ) digits = 8;
	else if ( v < 1000000000ull ) digits = 9;
	else if ( v < 10000000000ull ) digits = 10;
	else if ( v < 100000000000ull ) digits = 11;
	else if ( v < 1000000000000ull ) digits = 12;
	else if ( v < 10000000000000ull ) digits = 13;
	else if ( v < 100000000000000ull ) digits = 14;
	else if ( v < 1000000000000000ull ) digits = 15;
	else if ( v < 10000000000000000ull ) digits = 16;
	else if ( v < 100000000000000000ull ) digits = 17;
	else if ( v < 1000000000000000000ull ) digits = 18;
	else if ( v < 10000000000000000000ull ) digits = 19;
	else digits = 20;

	*(buf+digits) = 0;
	char *p = buf+digits-1;
	switch ( digits ) {
		case 20: *p-- = '0' + (v % 10); v /= 10;
		case 19: *p-- = '0' + (v % 10); v /= 10;
		case 18: *p-- = '0' + (v % 10); v /= 10;
		case 17: *p-- = '0' + (v % 10); v /= 10;
		case 16: *p-- = '0' + (v % 10); v /= 10;
		case 15: *p-- = '0' + (v % 10); v /= 10;
		case 14: *p-- = '0' + (v % 10); v /= 10;
		case 13: *p-- = '0' + (v % 10); v /= 10;
		case 12: *p-- = '0' + (v % 10); v /= 10;
		case 11: *p-- = '0' + (v % 10); v /= 10;
		case 10: *p-- = '0' + (v % 10); v /= 10;
		case 9 : *p-- = '0' + (v % 10); v /= 10;
		case 8 : *p-- = '0' + (v % 10); v /= 10;
		case 7 : *p-- = '0' + (v % 10); v /= 10;
		case 6 : *p-- = '0' + (v % 10); v /= 10;
		case 5 : *p-- = '0' + (v % 10); v /= 10;
		case 4 : *p-- = '0' + (v % 10); v /= 10;
		case 3 : *p-- = '0' + (v % 10); v /= 10;
		case 2 : *p-- = '0' + (v % 10); v /= 10;
		case 1 : *p-- = '0' + (v % 10); v /= 10;
	}

	return digits;
}

/***************************************************************************/

template<typename T>
std::uint32_t itoa(T v, char *buf) {
	if ( v < 0 ) { *buf++ = '-'; }
	v = std::abs(v);

	std::size_t digits = 0;
	if ( v < 10ll ) digits = 1;
	else if ( v < 100ll ) digits = 2;
	else if ( v < 1000ll ) digits = 3;
	else if ( v < 10000ll ) digits = 4;
	else if ( v < 100000ll ) digits = 5;
	else if ( v < 1000000ll ) digits = 6;
	else if ( v < 10000000ll ) digits = 7;
	else if ( v < 100000000ll ) digits = 8;
	else if ( v < 1000000000ll ) digits = 9;
	else if ( v < 10000000000ll ) digits = 10;
	else if ( v < 100000000000ll ) digits = 11;
	else if ( v < 1000000000000ll ) digits = 12;
	else if ( v < 10000000000000ll ) digits = 13;
	else if ( v < 100000000000000ll ) digits = 14;
	else if ( v < 1000000000000000ll ) digits = 15;
	else if ( v < 10000000000000000ll ) digits = 16;
	else if ( v < 100000000000000000ll ) digits = 17;
	else if ( v < 1000000000000000000ll ) digits = 18;
	else digits = 19;

	*(buf+digits) = 0;
	char *p = buf+digits-1;
	switch ( digits ) {
		case 19: *p-- = '0' + (v % 10); v /= 10;
		case 18: *p-- = '0' + (v % 10); v /= 10;
		case 17: *p-- = '0' + (v % 10); v /= 10;
		case 16: *p-- = '0' + (v % 10); v /= 10;
		case 15: *p-- = '0' + (v % 10); v /= 10;
		case 14: *p-- = '0' + (v % 10); v /= 10;
		case 13: *p-- = '0' + (v % 10); v /= 10;
		case 12: *p-- = '0' + (v % 10); v /= 10;
		case 11: *p-- = '0' + (v % 10); v /= 10;
		case 10: *p-- = '0' + (v % 10); v /= 10;
		case 9 : *p-- = '0' + (v % 10); v /= 10;
		case 8 : *p-- = '0' + (v % 10); v /= 10;
		case 7 : *p-- = '0' + (v % 10); v /= 10;
		case 6 : *p-- = '0' + (v % 10); v /= 10;
		case 5 : *p-- = '0' + (v % 10); v /= 10;
		case 4 : *p-- = '0' + (v % 10); v /= 10;
		case 3 : *p-- = '0' + (v % 10); v /= 10;
		case 2 : *p-- = '0' + (v % 10); v /= 10;
		case 1 : *p-- = '0' + (v % 10); v /= 10;
	}

	return digits;
}

/***************************************************************************/

template<typename T>
inline T atod(const char *p) {
	T r = 0.0;
	bool neg = false;
	if (*p == '-') {
		neg = true;
		++p;
	}
	while (*p >= '0' && *p <= '9') {
		r = (r*10.0) + (*p - '0');
		++p;
	}
	if (*p == '.') {
		double f = 0.0;
		int n = 0;
		++p;
		while (*p >= '0' && *p <= '9') {
			f = (f*10.0) + (*p - '0');
			++p;
			++n;
		}
		r += f / std::pow(10.0, n);
	}
	if (neg) r = -r;

	return r;
}

inline void strreverse(char* begin, char* end) {
	char aux;
	while (end > begin)
		aux = *end, *end-- = *begin, *begin++ = aux;
}

// from https://code.google.com/p/stringencoders/wiki/NumToA
template<typename T>
inline size_t modp_dtoa(T value, char* str, int prec) {
	static const double powers_of_10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
	 /* Hacky test for NaN
	  * under -fast-math this won't work, but then you also won't
	  * have correct nan values anyways.  The alternative is
	  * to link with libmath (bad) or hack IEEE double bits (bad)
	  */
	 if (! (value == value)) {
		  str[0] = 'n'; str[1] = 'a'; str[2] = 'n'; str[3] = '\0';
		  return (size_t)3;
	 }
	 /* if input is larger than thres_max, revert to exponential */
	 const double thres_max = (double)(0x7FFFFFFF);

	 double diff = 0.0;
	 char* wstr = str;

	 if (prec < 0) {
		  prec = 0;
	 } else if (prec > 9) {
		  /* precision of >= 10 can lead to overflow errors */
		  prec = 9;
	 }


	 /* we'll work in positive values and deal with the
		 negative sign issue later */
	 int neg = 0;
	 if (value < 0) {
		  neg = 1;
		  value = -value;
	 }


	 int whole = (int) value;
	 double tmp = (value - whole) * powers_of_10[prec];
	 uint32_t frac = (uint32_t)(tmp);
	 diff = tmp - frac;

	 if (diff > 0.5) {
		  ++frac;
		  /* handle rollover, e.g.  case 0.99 with prec 1 is 1.0  */
		  if (frac >= powers_of_10[prec]) {
				frac = 0;
				++whole;
		  }
	 } else if (diff == 0.5 && ((frac == 0) || (frac & 1))) {
		  /* if halfway, round up if odd, OR
			  if last digit is 0.  That last part is strange */
		  ++frac;
	 }

	 /* for very large numbers switch back to native sprintf for exponentials.
		 anyone want to write code to replace this? */
	 /*
		normal printf behavior is to print EVERY whole number digit
		which can be 100s of characters overflowing your buffers == bad
	 */
	 if (value > thres_max) {
		  sprintf(str, "%e", neg ? -value : value);
		  return strlen(str);
	 }

	 if (prec == 0) {
		  diff = value - whole;
		  if (diff > 0.5) {
				/* greater than 0.5, round up, e.g. 1.6 -> 2 */
				++whole;
		  } else if (diff == 0.5 && (whole & 1)) {
				/* exactly 0.5 and ODD, then round up */
				/* 1.5 -> 2, but 2.5 -> 2 */
				++whole;
		  }
	 } else {
		  int count = prec;
		  // now do fractional part, as an unsigned number
		  do {
				--count;
				*wstr++ = (char)(48 + (frac % 10));
		  } while (frac /= 10);
		  // add extra 0s
		  while (count-- > 0) *wstr++ = '0';
		  // add decimal
		  *wstr++ = '.';
	 }

	 // do whole part
	 // Take care of sign
	 // Conversion. Number is reversed.
	 do *wstr++ = (char)(48 + (whole % 10)); while (whole /= 10);
	 if (neg) {
		  *wstr++ = '-';
	 }
	 *wstr='\0';
	 strreverse(str, wstr-1);
	 return (size_t)(wstr - str);
}

/***************************************************************************/

} // ns detail
} // ns yas

#endif // _yas__detail__io__convertors_hpp
