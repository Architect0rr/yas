
// Copyright (c) 2010-2014 niXman (i dot nixman dog gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <iostream>
#include <chrono>
#include <sstream>

#include <yas/binary_oarchive.hpp>
#include <yas/binary_iarchive.hpp>
#include <yas/text_iarchive.hpp>
#include <yas/text_oarchive.hpp>
#include <yas/mem_streams.hpp>
#include <yas/detail/tools/buffers.hpp>
#include <yas/detail/tools/hexdumper.hpp>
#include <yas/serializers/std_types_serializers.hpp>

#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>

/***************************************************************************/

#define ASSERT(expr, type, dir) \
	if ( !(expr) ) throw std::runtime_error(__FILE__ "(" YAS_PP_STRINGIZE(__LINE__) "):[" type ":" dir "]: " #expr)

/***************************************************************************/

struct pod_type {
	bool a;
	std::int8_t b;
	std::int16_t c;
	std::int32_t d;
	std::int64_t e;
	std::size_t f;
	float g;
	double h;

	/** boost.serialization calls only this method */
	template<typename Archive>
	void serialize(Archive& ar, const unsigned int) {
		ar & a
			& b
			& c
			& d
			& e
			& f
			& g
			& h;
	}

	template<typename Archive>
	void serialize(Archive& ar) {
		ar & a
			& b
			& c
			& d
			& e
			& f
			& g
			& h;
	}
};

/***************************************************************************/

struct test_result {
	std::chrono::milliseconds save;
	std::chrono::milliseconds load;
	std::size_t size;
};

/***************************************************************************/

template<typename OA>
std::chrono::milliseconds save(OA &oa, const std::size_t iterations) {
	pod_type pt;
	auto s1 = std::chrono::system_clock::now();
	for ( size_t idx = 0; idx < iterations; ++idx ) {
		pt.a = idx;
		pt.b = idx;
		pt.c = idx;
		pt.d = idx;
		pt.e = idx;
		pt.f = idx;
		pt.g = idx;
		pt.h = idx;
		oa & pt;
	}
	return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - s1);
}

template<typename IA>
std::chrono::milliseconds load(IA &ia, const std::size_t iterations) {
	pod_type pt;
	auto s1 = std::chrono::system_clock::now();
	for ( size_t idx = 0; idx < iterations; ++idx ) {
		ia & pt;
		ASSERT(pt.f == idx, "boost::binary", "load");
	}
	return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - s1);
}

/***************************************************************************/

test_result boost_binary_test(const std::size_t iterations) {
	test_result res;
	std::ostringstream os;
	boost::archive::binary_oarchive oa(os, boost::archive::no_header);
	res.save = save(oa, iterations);

	res.size = os.str().length();

	std::istringstream is(os.str());
	boost::archive::binary_iarchive ia(is, boost::archive::no_header);
	res.load = load(ia, iterations);

	return res;
}

test_result boost_text_test(const std::size_t iterations) {
	test_result res;
	std::ostringstream os;
	boost::archive::text_oarchive oa(os, boost::archive::no_header);
	res.save = save(oa, iterations);

	res.size = os.str().length();

	std::istringstream is(os.str());
	boost::archive::text_iarchive ia(is, boost::archive::no_header);
	res.load = load(ia, iterations);

	return res;
}

/***************************************************************************/

test_result yas_binary_test(const std::size_t iterations) {
	test_result res;
	yas::mem_ostream os;
	yas::binary_oarchive<yas::mem_ostream> oa(os, yas::no_header);
	res.save = save(oa, iterations);

	res.size = os.get_intrusive_buffer().size;

	const yas::intrusive_buffer buf = os.get_intrusive_buffer();
	yas::mem_istream is(buf.data, buf.size);
	yas::binary_iarchive<yas::mem_istream> ia(is, yas::no_header);
	res.load = load(ia, iterations);

	return res;
}

test_result yas_text_test(const std::size_t iterations) {
	test_result res;
	yas::mem_ostream os;
	yas::text_oarchive<yas::mem_ostream> oa(os, yas::no_header);
	res.save = save(oa, iterations);

	res.size = os.get_intrusive_buffer().size;

	const yas::intrusive_buffer buf = os.get_intrusive_buffer();
	yas::mem_istream is(buf.data, buf.size);
	yas::text_iarchive<yas::mem_istream> ia(is, yas::no_header);
	res.load = load(ia, iterations);

	return res;
}

/***************************************************************************/

int main() {
	setvbuf(stdout, 0, _IONBF, 0);
	std::cout << "platform bits: " << (YAS_PLATFORM_BITS()) << std::endl;

	static const std::size_t iterations = 1024*1024;

	try {
		test_result bb, bt, yb, yt;
		bb = boost_binary_test(iterations);
		std::cout
		<< "binary:" << std::endl
		<< "   boost save time  : " << bb.save.count() << " ms" << std::endl
		<< "   boost load time  : " << bb.load.count() << " ms" << std::endl
		<< "   boost data size  : " << bb.size << std::endl;
		yb = yas_binary_test(iterations);
		std::cout
		<< "   yas save time    : " << yb.save.count() << " ms" << std::endl
		<< "   yas load time    : " << yb.load.count() << " ms" << std::endl
		<< "   yas data size    : " << yb.size << std::endl
		<< "   yas save speed up: " << (((double)bb.save.count())/((double)yb.save.count())) << std::endl
		<< "   yas load speed up: " << (((double)bb.load.count())/((double)yb.load.count())) << std::endl;

		bt = boost_text_test(iterations);
		std::cout
		<< "text:" << std::endl
		<< "   boost save time  : " << bt.save.count() << " ms" << std::endl
		<< "   boost load time  : " << bt.load.count() << " ms" << std::endl
		<< "   boost data size  : " << bt.size << std::endl;
		yt = yas_text_test(iterations);
		std::cout
		<< "   yas save time    : " << yt.save.count() << " ms" << std::endl
		<< "   yas load time    : " << yt.load.count() << " ms" << std::endl
		<< "   yas data size    : " << yt.size << std::endl
		<< "   yas save speed up: " << (((double)bt.save.count())/((double)yt.save.count())) << std::endl
		<< "   yas load speed up: " << (((double)bt.load.count())/((double)yt.load.count())) << std::endl;
	} catch (const std::exception &ex) {
		std::cout << "[exception]: " << ex.what() << std::endl;
	}
}

/***************************************************************************/
